//===============================================================================
// Ansteuerung Noritake GU128x32-800A mit M68 Parallel-Interface
// J2 MUSS gesetzt sein = M68
//
// HW:
// - Arduino Mega 2560
// - Noritake GU128X32-800A ueber M68 Parallel Interface, serial hat Probleme
//   gemacht. J2 muss verbunden sein fuer M68
// - Adafruit GPS Board an TX1/RX1
// - Odroid Weather Board
//   - SI7020
//     - Temparture / Hummidity
//   - BMP 180
//     - Temperature
//     - Baro/Altitude
//   - SI1132 (Adafruit Lib anpassen, siehe unten
//     - Illumination
//     - Ultraviolet Index (UV)   
//===============================================================================
// 13-Sep-2018 bue Firstlight
// 14-Sep-2018 bue Massiver Ausbau
//                 RTC (Chronodot 2.1 DS3231) eingebaut
//                 Einbau der alten Sommer/Winterzeit Routinen
//                 Daten im Sekundentakt auf VFD schreiben.
// 20-Sep-2018 bue Neu HW geloetet. Kontrollpins anders belegt
// 29-Sep-2018 bue 0.8 Odroid Weatherboard angehaengt. 
// 30-Sep-2018 bue 0.9 Bugfixing und Hoehenkorrektur des Luftdrucks
//===============================================================================
// Dank gebuehrt:
//   - Peter Dannegger (danni@specs.de) fuer einen Teil der Zeitroutinen
//   - Noritake fuer das Grundgeruest der VFD Routinen
//   - Und alle, die ich vergessen habe :-)
//===============================================================================
// VFD Display Organisation (immer noch ein Raetsel....)
//
// FONT14X10: 0,0 (x,y) --> obere linke Ecke.
//            18,1 --> 18 Pixel nach links, aber 8 Pixel nach unten (y immer in 8'er Schritten)
//            Gibt also im Moment nur ca. 2 x 10 Zeilen.
//
// FONT7x5: Das Gleiche, hier ergibt das 4 x 20 Zeichen, x = 0-128, y = 0 - 3
//===============================================================================
// Anpassungen Adafruit SI1145 Lib
// in Adafruit_SI1145.cpp:
//     // if (id != 0x45) return false; // look for SI1145
//     if ((id != 0x32) && (id != 0x45)) return false; // look for SI1132 or SI1145
// Sonst wird Sensor SI1132 nicht erkannt
// Gemessene Daten:
// Dunkel: 260 
// Neonlampe: 400
// HighPower LED: > 800
//===============================================================================

#include <Wire.h>
#include <Adafruit_GPS.h>
#include <Adafruit_BMP085.h>
#include <Adafruit_SI1145.h>  // Muss angepasst werden fuer SI1132 (siehe Doku oben)
#include <Adafruit_Si7021.h>
#include <DS3231.h>

// Port names
#define VFD_COMMAND     PORTF   // Control port
#define VFD_DATA        PORTK   // Data port

// PF4 CS
// PF5 RD
// PF6 CD
// PF7 WR

// Control port pins
#define WRHI            0x80
#define WRLO            0
#define RDHI            0x20
#define RDLO            0
#define CSSHI           0x10
#define CSSLO           0
#define CDHI            0x40
#define CDLO            0

#define D7              0x80
#define D6              0x40
#define D5              0x20
#define D4              0x10
#define D3              0x08
#define D2              0x04
#define D1              0x02
#define D0              0x01

// Easier names for display settings
#define LAYER0_ON       1
#define LAYER0_OFF      0
#define LAYER1_ON       1
#define LAYER1_OFF      0
#define DISPLAY_ON      1
#define DISPLAY_OFF     0
#define REVERSE_ON      1
#define REVERSE_OFF     0
#define MODE_AND        0
#define MODE_EXOR       1
#define MODE_OR         2
#define VERTICAL_ON     1
#define VERTICAL_OFF    0
#define HORIZONTAL_ON   1
#define HORIZONTAL_OFF  0

#define FONT5X7   0x00
#define FONT10X14 0x01

const int buttonPin = 2;

unsigned char font_start;
unsigned char font_width;
unsigned char font_height;
unsigned char font_bytesize;
unsigned char font_space;
unsigned char *font_location;

unsigned char current_font;
unsigned char xpos, ypos;
unsigned char buffer[8];

/* Character data for the 5x7 font - codes 20 hex to 7F hex */

const unsigned char font5x7[] = {
  0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0xF2, 0x00, 0x00,
  0x00, 0xC0, 0x00, 0xC0, 0x00,
  0x28, 0xFE, 0x28, 0xFE, 0x28,
  0x24, 0x54, 0xFE, 0x54, 0x48,
  0xC4, 0xC8, 0x10, 0x26, 0x46,
  0x6C, 0x92, 0x9A, 0x64, 0x0A,
  0x00, 0xA0, 0xC0, 0x00, 0x00,
  0x00, 0x38, 0x44, 0x82, 0x00,
  0x00, 0x82, 0x44, 0x38, 0x00,
  0x28, 0x10, 0x7C, 0x10, 0x28,
  0x10, 0x10, 0x7C, 0x10, 0x10,
  0x0A, 0x0C, 0x00, 0x00, 0x00,
  0x10, 0x10, 0x10, 0x10, 0x10,
  0x06, 0x06, 0x00, 0x00, 0x00,
  0x04, 0x08, 0x10, 0x20, 0x40,
  0x7C, 0x8A, 0x92, 0xA2, 0x7C,
  0x00, 0x42, 0xFE, 0x02, 0x00,
  0x42, 0x86, 0x8A, 0x92, 0x62,
  0x84, 0x82, 0xA2, 0xD2, 0x8C,
  0x18, 0x28, 0x48, 0xFE, 0x08,
  0xE4, 0xA2, 0xA2, 0xA2, 0x9C,
  0x3C, 0x52, 0x92, 0x92, 0x0C,
  0x80, 0x8E, 0x90, 0xA0, 0xC0,
  0x6C, 0x92, 0x92, 0x92, 0x6C,
  0x60, 0x92, 0x92, 0x94, 0x78,
  0x00, 0x6C, 0x6C, 0x00, 0x00,
  0x00, 0x6A, 0x6C, 0x00, 0x00,
  0x10, 0x28, 0x44, 0x82, 0x00,
  0x28, 0x28, 0x28, 0x28, 0x28,
  0x00, 0x82, 0x44, 0x28, 0x10,
  0x40, 0x80, 0x8A, 0x90, 0x60,
  0x4C, 0x92, 0x9E, 0x82, 0x7C,
  0x3E, 0x48, 0x88, 0x48, 0x3E,
  0xFE, 0x92, 0x92, 0x92, 0x6C,
  0x7C, 0x82, 0x82, 0x82, 0x44,
  0xFE, 0x82, 0x82, 0x44, 0x38,
  0xFE, 0x92, 0x92, 0x82, 0x82,
  0xFE, 0x90, 0x90, 0x90, 0x80,
  0x7C, 0x82, 0x92, 0x92, 0x5C,
  0xFE, 0x10, 0x10, 0x10, 0xFE,
  0x00, 0x82, 0xFE, 0x82, 0x00,
  0x04, 0x02, 0x82, 0xFC, 0x80,
  0xFE, 0x10, 0x28, 0x44, 0x82,
  0xFE, 0x02, 0x02, 0x02, 0x02,
  0xFE, 0x40, 0x20, 0x40, 0xFE,
  0xFE, 0x20, 0x10, 0x08, 0xFE,
  0x7C, 0x82, 0x82, 0x82, 0x7C,
  0xFE, 0x90, 0x90, 0x90, 0x60,
  0x7C, 0x82, 0x8A, 0x84, 0x7A,
  0xFE, 0x90, 0x98, 0x94, 0x62,
  0x64, 0x92, 0x92, 0x92, 0x4C,
  0x80, 0x80, 0xFE, 0x80, 0x80,
  0xFC, 0x02, 0x02, 0x02, 0xFC,
  0xF8, 0x04, 0x02, 0x04, 0xF8,
  0xFC, 0x02, 0x0C, 0x02, 0xFC,
  0xC6, 0x28, 0x10, 0x28, 0xC6,
  0xE0, 0x10, 0x0E, 0x10, 0xE0,
  0x86, 0x8A, 0x92, 0xA2, 0xC2,
  0x00, 0xFE, 0x82, 0x82, 0x00,
  0x40, 0x20, 0x10, 0x08, 0x04,
  0x00, 0x82, 0x82, 0xFE, 0x00,
  0x20, 0x40, 0x80, 0x40, 0x20,
  0x02, 0x02, 0x02, 0x02, 0x02,
  0x00, 0x80, 0x40, 0x20, 0x00,
  0x04, 0x2A, 0x2A, 0x2A, 0x1E,
  0xFE, 0x12, 0x12, 0x12, 0x0C,
  0x1C, 0x22, 0x22, 0x22, 0x22,
  0x0C, 0x12, 0x12, 0x12, 0xFE,
  0x1C, 0x2A, 0x2A, 0x2A, 0x1A,
  0x10, 0x7E, 0x90, 0x40, 0x00,
  0x12, 0x2A, 0x2A, 0x2A, 0x3C,
  0xFE, 0x10, 0x10, 0x10, 0x0E,
  0x00, 0x00, 0x5E, 0x00, 0x00,
  0x04, 0x02, 0x02, 0xBC, 0x00,
  0xFE, 0x08, 0x14, 0x22, 0x00,
  0x00, 0x82, 0xFE, 0x02, 0x00,
  0x3E, 0x20, 0x18, 0x20, 0x3E,
  0x3E, 0x10, 0x20, 0x20, 0x1E,
  0x1C, 0x22, 0x22, 0x22, 0x1C,
  0x3E, 0x28, 0x28, 0x28, 0x10,
  0x10, 0x28, 0x28, 0x28, 0x3E,
  0x3E, 0x10, 0x20, 0x20, 0x10,
  0x12, 0x2A, 0x2A, 0x2A, 0x24,
  0x20, 0xFC, 0x22, 0x04, 0x00,
  0x3C, 0x02, 0x02, 0x02, 0x3C,
  0x38, 0x04, 0x02, 0x04, 0x38,
  0x3C, 0x02, 0x0C, 0x02, 0x3C,
  0x22, 0x14, 0x08, 0x14, 0x22,
  0x20, 0x12, 0x0C, 0x10, 0x20,
  0x22, 0x26, 0x2A, 0x32, 0x22,
  0x10, 0x6C, 0x82, 0x82, 0x00,
  0x12, 0x7E, 0x92, 0x82, 0x42,
  0x00, 0x82, 0x82, 0x6C, 0x10,
  0x80, 0x80, 0x80, 0x80, 0x80,
  0xFE, 0xFE, 0xFE, 0xFE, 0xFE
};

/* Character data for the 10x14 font - codes 20 hex to 7F hex */

const unsigned char font10x14[] = {

  // 0     1     2     3     4     5     6     7     8     9
  // SPACE
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xCC,
  0xFF, 0xCC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0xF0, 0x00, 0x00, 0x00,
  0x00, 0x00, 0xF0, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x0C, 0xC0, 0x0C, 0xC0, 0xFF, 0xFC, 0xFF, 0xFC, 0x0C, 0xC0,
  0x0C, 0xC0, 0xFF, 0xFC, 0xFF, 0xFC, 0x0C, 0xC0, 0x0C, 0xC0,
  0x0C, 0x60, 0x1E, 0x70, 0x3F, 0x30, 0x33, 0x30, 0xFF, 0xFC,
  0xFF, 0xFC, 0x33, 0x30, 0x33, 0xF0, 0x39, 0xE0, 0x18, 0xC0, //99
  // !
  0x60, 0x00, 0xF0, 0x0C, 0xF0, 0x3C, 0x60, 0xF0, 0x03, 0xC0,
  0x0F, 0x00, 0x3C, 0x18, 0xF0, 0x3C, 0xC0, 0x3C, 0x00, 0x18,
  0x3C, 0xF0, 0x7F, 0xF8, 0xC3, 0x1C, 0xC7, 0x8C, 0xCF, 0xCC,
  0xDC, 0xEC, 0x78, 0x78, 0x30, 0x30, 0x00, 0xFC, 0x00, 0xCC,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x00, 0xEC, 0x00,
  0xF8, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0F, 0xC0, 0x3F, 0xF0, 0x78, 0x78,
  0x60, 0x18, 0xC0, 0x0C, 0xC0, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x0C, 0xC0, 0x0C, 0x60, 0x18,
  0x78, 0x78, 0x3F, 0xF0, 0x0F, 0xC0, 0x00, 0x00, 0x00, 0x00, // 199
  // "
  0x0C, 0x60, 0x0E, 0xE0, 0x07, 0xC0, 0x03, 0x80, 0x3F, 0xF8,
  0x3F, 0xF8, 0x03, 0x80, 0x07, 0xC0, 0x0E, 0xE0, 0x0C, 0x60,
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x3F, 0xF0,
  0x3F, 0xF0, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00,
  0x00, 0x44, 0x00, 0xEC, 0x00, 0xF8, 0x00, 0x70, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00,
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00,
  0x00, 0x18, 0x00, 0x3C, 0x00, 0x3C, 0x00, 0x18, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 299
  // #
  0x00, 0x00, 0x00, 0x0C, 0x00, 0x3C, 0x00, 0xF0, 0x03, 0xC0,
  0x0F, 0x00, 0x3C, 0x00, 0xF0, 0x00, 0xC0, 0x00, 0x00, 0x00,
  0x3F, 0xF0, 0x7F, 0xF8, 0xE0, 0xFC, 0xC1, 0xCC, 0xC3, 0x8C,
  0xC7, 0x0C, 0xCE, 0x0C, 0xFC, 0x1C, 0x7F, 0xF8, 0x3F, 0xF0,
  0x00, 0x00, 0x00, 0x00, 0x30, 0x0C, 0x70, 0x0C, 0xFF, 0xFC,
  0xFF, 0xFC, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x30, 0x0C, 0x70, 0x1C, 0xE0, 0x3C, 0xC0, 0x7C, 0xC0, 0xEC,
  0xC1, 0xCC, 0xC3, 0x8C, 0xE7, 0x0C, 0x7E, 0x0C, 0x3C, 0x0C,
  0x30, 0x30, 0x70, 0x38, 0xE0, 0x1C, 0xC0, 0x0C, 0xC0, 0x0C,
  0xC3, 0x0C, 0xC3, 0x0C, 0xE3, 0x1C, 0x7F, 0xF8, 0x3C, 0xF0, // 399

  0x03, 0xC0, 0x07, 0xC0, 0x0E, 0xC0, 0x1C, 0xC0, 0x38, 0xC0,
  0x70, 0xC0, 0xFF, 0xFC, 0xFF, 0xFC, 0x00, 0xC0, 0x00, 0xC0,
  0xFC, 0x30, 0xFC, 0x38, 0xCC, 0x1C, 0xCC, 0x0C, 0xCC, 0x0C,
  0xCC, 0x0C, 0xCC, 0x0C, 0xCE, 0x1C, 0xC7, 0xF8, 0xC3, 0xF0,
  0x3F, 0xF0, 0x7F, 0xF8, 0xE3, 0x1C, 0xC3, 0x0C, 0xC3, 0x0C,
  0xC3, 0x0C, 0xC3, 0x0C, 0xE3, 0x9C, 0x71, 0xF8, 0x30, 0xF0,
  0xC0, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0xC3, 0xFC,
  0xC7, 0xFC, 0xCE, 0x00, 0xDC, 0x00, 0xF8, 0x00, 0xF0, 0x00,
  0x3C, 0xF0, 0x7F, 0xF8, 0xE7, 0x9C, 0xC3, 0x0C, 0xC3, 0x0C,
  0xC3, 0x0C, 0xC3, 0x0C, 0xE7, 0x9C, 0x7F, 0xF8, 0x3C, 0xF0, // 499

  0x3C, 0x00, 0x7E, 0x00, 0xE7, 0x0C, 0xC3, 0x0C, 0xC3, 0x1C,
  0xC3, 0x38, 0xC3, 0x70, 0xE7, 0xE0, 0x7F, 0xC0, 0x3F, 0x80,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x60, 0x3C, 0xF0,
  0x3C, 0xF0, 0x18, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x44, 0x3C, 0xEC,
  0x3C, 0xF8, 0x18, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x03, 0x00, 0x07, 0x80, 0x0F, 0xC0, 0x1C, 0xE0,
  0x38, 0x70, 0x70, 0x38, 0xE0, 0x1C, 0xC0, 0x0C, 0x00, 0x00,
  0x0C, 0xC0, 0x0C, 0xC0, 0x0C, 0xC0, 0x0C, 0xC0, 0x0C, 0xC0,
  0x0C, 0xC0, 0x0C, 0xC0, 0x0C, 0xC0, 0x0C, 0xC0, 0x0C, 0xC0, // 599

  0x00, 0x00, 0xC0, 0x0C, 0xE0, 0x1C, 0x70, 0x38, 0x38, 0x70,
  0x1C, 0xE0, 0x0F, 0xC0, 0x07, 0x80, 0x03, 0x00, 0x00, 0x00,
  0x30, 0x00, 0x70, 0x00, 0xE0, 0x00, 0xC0, 0x00, 0xC1, 0xEC,
  0xC3, 0xEC, 0xC3, 0x00, 0xE6, 0x00, 0x7E, 0x00, 0x3C, 0x00,
  0x30, 0xF0, 0x71, 0xF8, 0xE3, 0x9C, 0xC3, 0x0C, 0xC3, 0xFC,
  0xC3, 0xFC, 0xC0, 0x0C, 0xE0, 0x1C, 0x7F, 0xF8, 0x3F, 0xF0,
  0x3F, 0xFC, 0x7F, 0xFC, 0xE0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0,
  0xC0, 0xC0, 0xC0, 0xC0, 0xE0, 0xC0, 0x7F, 0xFC, 0x3F, 0xFC,
  0xFF, 0xFC, 0xFF, 0xFC, 0xC3, 0x0C, 0xC3, 0x0C, 0xC3, 0x0C,
  0xC3, 0x0C, 0xC3, 0x0C, 0xE7, 0x9C, 0x7F, 0xF8, 0x3C, 0xF0, // 699

  0x3F, 0xF0, 0x7F, 0xF8, 0xE0, 0x1C, 0xC0, 0x0C, 0xC0, 0x0C,
  0xC0, 0x0C, 0xC0, 0x0C, 0xE0, 0x1C, 0x70, 0x38, 0x30, 0x30,
  0xFF, 0xFC, 0xFF, 0xFC, 0xC0, 0x0C, 0xC0, 0x0C, 0xC0, 0x0C,
  0xC0, 0x0C, 0xC0, 0x0C, 0xE0, 0x1C, 0x7F, 0xF8, 0x3F, 0xF0,
  0xFF, 0xFC, 0xFF, 0xFC, 0xC3, 0x0C, 0xC3, 0x0C, 0xC3, 0x0C,
  0xC3, 0x0C, 0xC3, 0x0C, 0xC3, 0x0C, 0xC0, 0x0C, 0xC0, 0x0C,
  0xFF, 0xFC, 0xFF, 0xFC, 0xC3, 0x00, 0xC3, 0x00, 0xC3, 0x00,
  0xC3, 0x00, 0xC3, 0x00, 0xC3, 0x00, 0xC0, 0x00, 0xC0, 0x00,
  0x3F, 0xF0, 0x7F, 0xF8, 0xE0, 0x1C, 0xC0, 0x0C, 0xC0, 0x0C,
  0xC3, 0x0C, 0xC3, 0x0C, 0xE3, 0x1C, 0x73, 0xF8, 0x33, 0xF0, // 799
  // H
  0xFF, 0xFC, 0xFF, 0xFC, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00,
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0xFF, 0xFC, 0xFF, 0xFC,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x0C, 0xC0, 0x0C, 0xFF, 0xFC,
  0xFF, 0xFC, 0xC0, 0x0C, 0xC0, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x30, 0x00, 0x38, 0xC0, 0x1C, 0xC0, 0x0C, 0xC0, 0x0C,
  0xC0, 0x1C, 0xFF, 0xF8, 0xFF, 0xF0, 0xC0, 0x00, 0xC0, 0x00,
  0xFF, 0xFC, 0xFF, 0xFC, 0x07, 0x80, 0x07, 0x80, 0x0F, 0xC0,
  0x1C, 0xE0, 0x38, 0x70, 0x70, 0x38, 0xE0, 0x1C, 0xC0, 0x0C,
  0xFF, 0xFC, 0xFF, 0xFC, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C,
  0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, // 899

  0xFF, 0xFC, 0xFF, 0xFC, 0x70, 0x00, 0x38, 0x00, 0x1F, 0x00,
  0x1F, 0x00, 0x38, 0x00, 0x70, 0x00, 0xFF, 0xFC, 0xFF, 0xFC,
  0xFF, 0xFC, 0xFF, 0xFC, 0x1C, 0x00, 0x0E, 0x00, 0x07, 0x00,
  0x03, 0x80, 0x01, 0xC0, 0x00, 0xE0, 0xFF, 0xFC, 0xFF, 0xFC,
  0x3F, 0xF0, 0x7F, 0xF8, 0xE0, 0x1C, 0xC0, 0x0C, 0xC0, 0x0C,
  0xC0, 0x0C, 0xC0, 0x0C, 0xE0, 0x1C, 0x7F, 0xF8, 0x3F, 0xF0,
  0xFF, 0xFC, 0xFF, 0xFC, 0xC3, 0x00, 0xC3, 0x00, 0xC3, 0x00,
  0xC3, 0x00, 0xC3, 0x00, 0xE7, 0x00, 0x7E, 0x00, 0x3C, 0x00,
  0x3F, 0xF0, 0x7F, 0xF8, 0xE0, 0x1C, 0xC0, 0x0C, 0xC0, 0xCC,
  0xC0, 0xEC, 0xC0, 0x7C, 0xE0, 0x38, 0x7F, 0xFC, 0x3F, 0xEC,
  0xFF, 0xFC, 0xFF, 0xFC, 0xC3, 0x00, 0xC3, 0x80, 0xC3, 0x80,
  0xC3, 0xC0, 0xC3, 0xC0, 0xE7, 0x70, 0x7E, 0x3C, 0x3C, 0x1C,
  0x3C, 0x18, 0x7E, 0x1C, 0xE7, 0x0C, 0xC3, 0x0C, 0xC3, 0x0C,
  0xC3, 0x0C, 0xC3, 0x0C, 0xC3, 0x9C, 0xE1, 0xF8, 0x60, 0xF0,
  0xC0, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0xFF, 0xFC,
  0xFF, 0xFC, 0xC0, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0xC0, 0x00,
  0xFF, 0xF0, 0xFF, 0xF8, 0x00, 0x1C, 0x00, 0x0C, 0x00, 0x0C,
  0x00, 0x0C, 0x00, 0x0C, 0x00, 0x1C, 0xFF, 0xF8, 0xFF, 0xF0,
  0xFF, 0xC0, 0xFF, 0xE0, 0x00, 0x70, 0x00, 0x38, 0x00, 0x1C,
  0x00, 0x1C, 0x00, 0x38, 0x00, 0x70, 0xFF, 0xE0, 0xFF, 0xC0,
  0xFF, 0xF0, 0xFF, 0xF8, 0x00, 0x1C, 0x00, 0x3C, 0x00, 0xF8,
  0x00, 0xF8, 0x00, 0x3C, 0x00, 0x1C, 0xFF, 0xF8, 0xFF, 0xF0,
  0xF0, 0x3C, 0xF8, 0x7C, 0x1C, 0xE0, 0x0F, 0xC0, 0x07, 0x80,
  0x07, 0x80, 0x0F, 0xC0, 0x1C, 0xE0, 0xF8, 0x7C, 0xF0, 0x3C,
  0xFC, 0x00, 0xFE, 0x00, 0x07, 0x00, 0x03, 0x80, 0x01, 0xFC,
  0x01, 0xFC, 0x03, 0x80, 0x07, 0x00, 0xFE, 0x00, 0xFC, 0x00,
  0xC0, 0x3C, 0xC0, 0x7C, 0xC0, 0xEC, 0xC1, 0xCC, 0xC3, 0x8C,
  0xC7, 0x0C, 0xCE, 0x0C, 0xDC, 0x0C, 0xF8, 0x0C, 0xF0, 0x0C,
  0x00, 0x00, 0x00, 0x00, 0xFF, 0xFC, 0xFF, 0xFC, 0xC0, 0x0C,
  0xC0, 0x0C, 0xC0, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0xC0, 0x00, 0xF0, 0x00, 0x3C, 0x00, 0x0F, 0x00,
  0x03, 0xC0, 0x00, 0xF0, 0x00, 0x3C, 0x00, 0x0C, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x0C, 0xC0, 0x0C, 0xC0, 0x0C,
  0xFF, 0xFC, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x0C, 0x00, 0x1C, 0x00, 0x38, 0x00, 0x70, 0x00, 0xE0, 0x00,
  0xE0, 0x00, 0x70, 0x00, 0x38, 0x00, 0x1C, 0x00, 0x0C, 0x00,
  0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C,
  0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0xE0, 0x00, 0x70, 0x00,
  0x38, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x30, 0x06, 0x78, 0x0E, 0xFC, 0x0C, 0xCC, 0x0C, 0xCC,
  0x0C, 0xCC, 0x0C, 0xCC, 0x0E, 0xCC, 0x07, 0xFC, 0x03, 0xF8,
  0xFF, 0xFC, 0xFF, 0xFC, 0x03, 0x0C, 0x03, 0x0C, 0x03, 0x0C,
  0x03, 0x0C, 0x03, 0x0C, 0x03, 0x9C, 0x01, 0xF8, 0x00, 0xF0,
  0x03, 0xF0, 0x07, 0xF8, 0x0E, 0x1C, 0x0C, 0x0C, 0x0C, 0x0C,
  0x0C, 0x0C, 0x0C, 0x0C, 0x0E, 0x1C, 0x07, 0x38, 0x03, 0x30,
  0x00, 0xF0, 0x01, 0xF8, 0x03, 0x9C, 0x03, 0x0C, 0x03, 0x0C,
  0x03, 0x0C, 0x03, 0x0C, 0x03, 0x0C, 0xFF, 0xFC, 0xFF, 0xFC,
  0x03, 0xF0, 0x07, 0xF8, 0x0E, 0xDC, 0x0C, 0xCC, 0x0C, 0xCC,
  0x0C, 0xCC, 0x0C, 0xCC, 0x0E, 0xDC, 0x07, 0xD8, 0x03, 0x90,
  0x00, 0x00, 0x03, 0x00, 0x3F, 0xFC, 0x7F, 0xFC, 0xE3, 0x00,
  0xE3, 0x00, 0x70, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x03, 0x18, 0x07, 0x9C, 0x0F, 0xCC, 0x0C, 0xCC, 0x0C, 0xCC,
  0x0C, 0xCC, 0x0C, 0xCC, 0x0C, 0xDC, 0x0F, 0xF8, 0x07, 0xF0,
  0xFF, 0xFC, 0xFF, 0xFC, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00,
  0x03, 0x00, 0x03, 0x80, 0x01, 0xFC, 0x00, 0xFC, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0xFC,
  0x1B, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x30, 0x00, 0x38, 0x00, 0x1C, 0x00, 0x0C,
  0x00, 0x0C, 0x00, 0x1C, 0xCF, 0xF8, 0xCF, 0xF0, 0x00, 0x00,
  0x00, 0x00, 0xFF, 0xFC, 0xFF, 0xFC, 0x00, 0xE0, 0x01, 0xE0,
  0x03, 0xF0, 0x07, 0x38, 0x0E, 0x1C, 0x0C, 0x0C, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC0, 0x0C, 0xC0, 0x0C, 0xFF, 0xFC,
  0xFF, 0xFC, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
  0x0F, 0xFC, 0x0F, 0xFC, 0x0E, 0x00, 0x07, 0x00, 0x03, 0xC0,
  0x03, 0xC0, 0x07, 0x00, 0x0E, 0x00, 0x0F, 0xFC, 0x0F, 0xFC,
  0x0F, 0xFC, 0x0F, 0xFC, 0x03, 0x00, 0x07, 0x00, 0x0E, 0x00,
  0x0C, 0x00, 0x0C, 0x00, 0x0E, 0x00, 0x07, 0xFC, 0x03, 0xFC,
  0x03, 0xF0, 0x07, 0xF8, 0x0E, 0x1C, 0x0C, 0x0C, 0x0C, 0x0C,
  0x0C, 0x0C, 0x0C, 0x0C, 0x0E, 0x1C, 0x07, 0xF8, 0x03, 0xF0,
  0x0F, 0xFC, 0x0F, 0xFC, 0x0C, 0xC0, 0x0C, 0xC0, 0x0C, 0xC0,
  0x0C, 0xC0, 0x0C, 0xC0, 0x0F, 0xC0, 0x07, 0x80, 0x03, 0x00,
  0x03, 0x00, 0x07, 0x80, 0x0F, 0xC0, 0x0C, 0xC0, 0x0C, 0xC0,
  0x0C, 0xC0, 0x0C, 0xC0, 0x0C, 0xC0, 0x0F, 0xFC, 0x0F, 0xFC,
  0x0F, 0xFC, 0x0F, 0xFC, 0x03, 0x80, 0x07, 0x00, 0x0E, 0x00,
  0x0C, 0x00, 0x0C, 0x00, 0x0E, 0x00, 0x07, 0x00, 0x03, 0x00,
  0x03, 0x18, 0x07, 0x9C, 0x0F, 0xCC, 0x0C, 0xCC, 0x0C, 0xCC,
  0x0C, 0xCC, 0x0C, 0xCC, 0x0C, 0xFC, 0x0E, 0x78, 0x06, 0x30,
  0x00, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0xFF, 0xF0, 0xFF, 0xF8,
  0x0C, 0x1C, 0x0C, 0x1C, 0x0C, 0x38, 0x0C, 0x30, 0x00, 0x00,
  0x0F, 0xF0, 0x0F, 0xF8, 0x00, 0x1C, 0x00, 0x0C, 0x00, 0x0C,
  0x00, 0x0C, 0x00, 0x0C, 0x00, 0x1C, 0x0F, 0xF8, 0x0F, 0xF0,
  0x0F, 0xC0, 0x0F, 0xE0, 0x00, 0x70, 0x00, 0x38, 0x00, 0x1C,
  0x00, 0x1C, 0x00, 0x38, 0x00, 0x70, 0x0F, 0xE0, 0x0F, 0xC0,
  0x0F, 0xF0, 0x0F, 0xF8, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0xF8,
  0x00, 0xF8, 0x00, 0x1C, 0x00, 0x1C, 0x0F, 0xF8, 0x0F, 0xF0,
  0x0C, 0x0C, 0x0E, 0x1C, 0x07, 0x38, 0x03, 0xF0, 0x01, 0xE0,
  0x01, 0xE0, 0x03, 0xF0, 0x07, 0x38, 0x0E, 0x1C, 0x0C, 0x0C,
  0x0C, 0x00, 0x0E, 0x00, 0x07, 0x0C, 0x03, 0x9C, 0x01, 0xF8,
  0x01, 0xF0, 0x03, 0x80, 0x07, 0x00, 0x0E, 0x00, 0x0C, 0x00,
  0x0C, 0x0C, 0x0C, 0x1C, 0x0C, 0x3C, 0x0C, 0x7C, 0x0C, 0xEC,
  0x0D, 0xCC, 0x0F, 0x8C, 0x0F, 0x0C, 0x0E, 0x0C, 0x0C, 0x0C,
  0x00, 0x00, 0x03, 0x00, 0x07, 0x80, 0x3F, 0xF0, 0x7C, 0xF8,
  0xE0, 0x1C, 0xC0, 0x0C, 0xC0, 0x0C, 0xC0, 0x0C, 0x00, 0x00,
  0x03, 0x0C, 0x03, 0x0C, 0x3F, 0xFC, 0x7F, 0xFC, 0xE3, 0x0C,
  0xC3, 0x0C, 0xC0, 0x0C, 0xE0, 0x0C, 0x70, 0x0C, 0x30, 0x0C,
  0x00, 0x00, 0xC0, 0x0C, 0xC0, 0x0C, 0xC0, 0x0C, 0xE0, 0x1C,
  0x7C, 0xF8, 0x3F, 0xF0, 0x07, 0x80, 0x03, 0x00, 0x00, 0x00,
  0xC0, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0xC0, 0x00,
  0xC0, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0xC0, 0x00,
  0xFF, 0xFC, 0xFF, 0xFC, 0xFF, 0xFC, 0xFF, 0xFC, 0xFF, 0xFC,
  0xFF, 0xFC, 0xFF, 0xFC, 0xFF, 0xFC, 0xFF, 0xFC, 0xFF, 0xFC,
};

// Temp / Feuchte
Adafruit_Si7021 sensor = Adafruit_Si7021();

// Licht
Adafruit_SI1145 uv = Adafruit_SI1145();

// Luftdruck
Adafruit_BMP085 bmp;

// RTG stuff
DS3231 Clock;

bool Century = false;
bool h12 = false;
bool PM = false;

// GPS stuff
#define GPSSerial Serial1
Adafruit_GPS GPS(&GPSSerial);

// Timerstuff
// Alte Routinen aus grauer Vorzeit...
uint32_t timer = millis();

bool set_time = true;
int sec_counter = 0;

// 1.1.1970 war ein Donnerstag
#define FIRSTYEAR  1970    // start year
#define FIRSTDAY  4     // 0 = Sunday

typedef struct
{
  uint8_t   second;
  uint8_t   minute;
  uint8_t   hour;
  uint8_t   day;
  uint8_t   month;
  uint16_t  year;
  uint8_t   wday;
} DATETIME_T;

DATETIME_T tm;
typedef unsigned long time_t;
time_t ts;
const unsigned int DayOfMonth[] = { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

// Variables will change:
int buttonState;             // the current reading from the input pin
int lastButtonState = HIGH;   // the previous reading from the input pin
int reading;

// the following variables are unsigned longs because the time, measured in
// milliseconds, will quickly become a bigger number than can be stored in an int.
unsigned long lastDebounceTime = 0;  // the last time the output pin was toggled
unsigned long debounceDelay = 100;    // the debounce time; increase if the output flickers

char disp_state = 0;

// Odroid Weather Board Sensoren

uint16_t Helligkeit = 0;
float Temp = 0.0;
float Humi = 0.0;
uint32_t Pressure = 0;

int bright = 0;

//=============================================================================
// Functions
//=============================================================================

//*********************************************************************
// VFD Routinen
//*********************************************************************
// Lowlevel Routine zum Schreiben eines Datenbytes auf das VFD
//*********************************************************************

void VFD_WriteData(unsigned char data)
{
  VFD_COMMAND = CDLO | WRLO | RDHI | CSSLO;
  VFD_DATA = data;
  VFD_COMMAND = CDLO | WRHI | RDHI | CSSLO;
}

//*********************************************************************
// Lowlevel Routine zum Schreiben eines Kommandobytes auf das VFD
//*********************************************************************

void VFD_WriteCtrl(unsigned char command)
{
  VFD_COMMAND = CDHI | WRLO | RDHI | CSSLO;
  VFD_DATA = command;
  VFD_COMMAND = CDHI | WRHI | RDHI | CSSLO;
}

//*********************************************************************
// On/Off Horizontal und Vertical Address Auto Increment
//*********************************************************************

void VFD_AddressIncrementMode(unsigned char h, unsigned char v)
{
  unsigned char bit2 = 0, bit1 = 0;

  if (h == HORIZONTAL_ON) bit2 = 0x04;
  if (v == VERTICAL_ON) bit1 = 0x02;
  VFD_WriteCtrl(0x80 + bit2 + bit1);
}

//*********************************************************************
// Set x-pos
//*********************************************************************

void VFD_SetColumn(unsigned char column)
{
  VFD_WriteCtrl(0x64);
  VFD_WriteCtrl(column);
}

//*********************************************************************
// Set y-pos
//*********************************************************************

void VFD_SetRow(unsigned char row)
{
  VFD_WriteCtrl(0x60);
  VFD_WriteCtrl(row);
}

//*********************************************************************
// Brightness
//*********************************************************************

void VFD_SetBrightness(unsigned char brightness)
{
  if (brightness > 15) brightness = 15; // Check for too big values
  if (brightness < 0) brightness = 0; // Check for too small values
  VFD_WriteCtrl(0x40 + (0x0F - brightness));
  delay(1);
}

//*********************************************************************
// Clear Display
//*********************************************************************

void VFD_ClearDisplay(void)
{
  VFD_WriteCtrl(0x5f);
  delay(1); // 1 ms delay needed for display clear command
}

//*********************************************************************
//  Set layers on/off + other display attributes
//*********************************************************************

void VFD_DisplaySetup(char layer0, char layer1, char gfx_on_off, char reverse, char mode)
{
  unsigned char l0 = 0, l1 = 0, gs = 0, grv = 0, tand = 0, exor = 0;

  if (layer0 == LAYER0_ON) l0 = D2;
  if (layer1 == LAYER1_ON) l1 = D3;
  VFD_WriteCtrl(0x20 + l0 + l1);

  if (gfx_on_off == DISPLAY_ON) gs = D6;
  if (reverse == REVERSE_ON) grv = D4;
  if (mode == MODE_AND) tand = D3;
  if (mode == MODE_EXOR) exor = D2;
  if (mode == MODE_OR) { }
  VFD_WriteCtrl(gs + grv + tand + exor);
}

//*********************************************************************
// VFD Init Routine 
//*********************************************************************

void VFD_Init(void)
{
  unsigned char i;

  for (i = 0; i < 8; i++)
  {
    // address area set
    VFD_WriteCtrl(0x62);
    VFD_WriteCtrl(i);
    VFD_WriteData(0xff);
  }

  VFD_AddressIncrementMode(HORIZONTAL_ON, VERTICAL_OFF); // Default to horizontal address increment ON
  VFD_SetColumn(0); // Set address pointer to (0,0)
  VFD_SetRow(0); // Set address pointer to (0,0)
  VFD_SetBrightness(0); // Set brightness to lowest possible

  VFD_DisplaySetup(LAYER0_OFF, LAYER1_OFF, DISPLAY_OFF, REVERSE_OFF, MODE_AND); // Set everything OFF
  VFD_ClearDisplay();
}


//*********************************************************************
// Font routines from Noritake
//*********************************************************************
//  Select Font
//*********************************************************************

void select_font(unsigned char f)
{
  switch (f)
  {
    case 0:
      font_start = 0x20;
      font_width = 0x05;
      font_height = 0x07;
      font_bytesize = 0x05;
      font_space = 0x01;
      font_location = &font5x7[0];
      break;
    case 1:
      font_start = 0x20;
      font_width = 0x0a;
      font_height = 0x0e;
      font_bytesize = 0x14;
      font_space = 0x02;
      font_location = &font10x14[0];
      break;
  }
}

//*********************************************************************
// Swap bytes
//*********************************************************************

unsigned char swap(unsigned char x)
{
  unsigned char result = 0, mask1 = 1, mask2 = 128;
  int b;

  for (b = 0; b < 8; b++)
  {
    if ((x & mask1) == mask1)
      result = result + mask2;
    mask1 = mask1 << 1;
    mask2 = mask2 >> 1;
  }
  return (result);
}

//*********************************************************************
// Write single charater
//*********************************************************************

void chr_wr(unsigned char code)
{
  unsigned char a, b, c, val;
  int fp;

  c = (font_height / 8) + 1;

  if (code >= font_start)         /* is character code in font range ? */
  {
    code -= font_start;         /* subtract start code */
    for (a = 0; a < font_width; a++)
    {
      set_position();
      for (b = 0; b < c; b++)
      {
        fp = code * font_bytesize + a * c + b;
        val = font_location[code * font_bytesize + a * c + b];
        val = swap(val);
        VFD_WriteData(val);
      }
      xpos++;
    }
    xpos += font_space;
  }
}

//*********************************************************************
// Set position on VFD, autoincrement will do the rest...
//*********************************************************************

void set_position(void)
{
  VFD_SetColumn(xpos);
  VFD_SetRow(ypos);
}

//*********************************************************************
// Write a string to a specific x,y position
//*********************************************************************

void put_txt(unsigned char *text, int x, int y)
{
  char c;

  xpos = x;
  ypos = y;

  while ( ( c = *text++) ) {
    chr_wr(c);
  }
}

//*********************************************************************
// Draw vertical bar (not used right now)
//*********************************************************************

void DrawVertBar(unsigned char height, unsigned char pos)
{
  unsigned char i;

  VFD_AddressIncrementMode(HORIZONTAL_OFF, VERTICAL_ON); // Vertical bars are drawn so vertical auto increment is enabled
  VFD_SetColumn(pos);
  VFD_SetRow(7 - height);

  for (i = 7 - height; i < 8; i++)
  {
    VFD_WriteData(254); // Draw vertical byte with one bit off: oxxxxxxx
    // Address pointer is incremented vertically after every byte written
  }
}

//*********************************************************************
// Zeitroutinen von Peter Dannegger
//*********************************************************************
// Umwandeln Timestamp in Datumsstruktur
//*********************************************************************

void gettime( volatile time_t sec, volatile DATETIME_T *t )
{
  unsigned long day;
  unsigned int year;
  unsigned short dayofyear;
  unsigned int leap400;
  unsigned int month;

  unsigned long t_sec;

  t_sec = sec;

  t->second = (sec % 60);
  t->minute = (sec / 60) % 60;
  t->hour   = (sec / 3600) % 24;
  day = (sec / 3600 ) / 24;

  t->wday = (day + FIRSTDAY) % 7;    // weekday

  year = FIRSTYEAR % 100;     // 0..99

  leap400 = 4 - ((FIRSTYEAR - 1) / 100 & 3);  // 4, 3, 2, 1

  for (;;)
  {
    dayofyear = 365;
    if ( (year & 3) == 0 )
    {
      dayofyear = 366;          // leap year
      if ( year == 0 || year == 100 || year == 200 ) // 100 year exception
      {
        if ( --leap400 )        // 400 year exception
        {
          dayofyear = 365;
        }
      }
    }
    if ( day < dayofyear ) break;
    day -= dayofyear;
    year++;         // 00..136 / 99..235
  }

  t->year = year + FIRSTYEAR / 100 * 100; // + century

  if ( dayofyear & 1 && day > 58 )  // no leap year and after 28.2.
    day++;          // skip 29.2.

  for ( month = 1; day >= DayOfMonth[month - 1]; month++ )
  {
    day -= DayOfMonth[month - 1];
  }

  t->month = month;       // 1..12
  t->day = day + 1;       // 1..31

}

//*********************************************************************
// Umwandeln Datumsstruktur in Timestamp
//*********************************************************************

time_t mktime(volatile DATETIME_T *timeptr)
{
  unsigned int year = timeptr->year;
  unsigned int month = timeptr->month;
  unsigned int i;
  volatile time_t seconds;

  // Sekunden vom 1.1.1970 00:00:00 bis zum 1.Jan des angegebenen Jahres 00:00:00

  seconds = (year - 1970) * 31536000; // (60*60*24L*365);

  // Fuer jedes schaltjahr einen Tag dazuzaehlen

  for (i = 1970; i < year; i++) {
    if (schaltjahr(i)) {
      seconds += 86400; // 86400 sind die Sekunden pro 24h oder Tag
    }
  }

  // Die restlichen Tage dieses Jahres addieren, ohne aktuellen Monat

  for (i = 0; i < (month - 1); i++) {
    // Wenn Februar ist und ein schaltjahr

    // Anpassung an die Routine von Peter Dannegger gettime(), dort wird der Februar in
    // der Tabelle mit 29 Tagen gefuehrt und ich mag nicht die Routine umbauen,
    // desshalb hier eine kleine Anpassung
    // Original:

    // if (i==1 && schaltjahr(year)) {
    //  seconds+= 2505600;  // 60*60*24*29 oder die Sekunden fuer 29 Tage addieren
    // } else {
    //  seconds+= 86400*DayOfMonth[i];
    // }

    if (i == 1 && (! schaltjahr(year))) {
      seconds += 28 * 86400L; // Normaler Februar
    } else {
      seconds += 86400 * DayOfMonth[i];
    }
  }

  // Die restlichen Tage des aktuellen Monats addieren, ohne den aktuellen Tag
  seconds += (timeptr->day - 1) * 86400L;
  // Stunden des aktuellen Tages addieren
  seconds += (timeptr->hour) * 3600L;
  // Minuten des aktuellen Tages addieren
  seconds += (timeptr->minute) * 60L;
  // Sekunden des aktuellen Tages addieren
  seconds += timeptr->second;

  Serial.print("Timestamp: ");
  Serial.println(seconds, DEC);

  return seconds;
}

//*********************************************************************
// Bestimmen, ob ein Jahr ein schaltjahr ist
//*********************************************************************

unsigned int schaltjahr( unsigned int year )
{
  return ( ( ( ( year % 4 ) == 0 ) &&
             ( ( year % 100 ) != 0 ) )
           || ( ( year % 400 ) == 0 ) );
}

//*********************************************************************
// Check ob Sommerzeit oder nicht
//*********************************************************************

void sommerzeit( volatile DATETIME_T *t )
{
  unsigned int hour, day, wday, month;      // locals for faster access

  hour = t->hour;
  day = t->day;
  wday = t->wday;
  month = t->month;

  // Ausserhalb moeglicher Sommerzeit, also nix machen
  if ( month < 3 || month > 10 ) return;

  // Letzer Sontag >= 02:00
  if ( day - wday >= 25 && (wday || hour >= 2) ) {
    if ( month == 10 )      // October -> Winter
      return;
  } else {                  // before last Sunday 2:00
    if ( month == 3 )       // March -> Winter
      return;
  }

  hour++;
  // Datum korrigieren, wenn Zeit ueberlaueft 23:00 -> 24:00
  if ( hour == 24 ) { 
    hour = 0;
    // Tag erhoehen
    wday++;
    if ( wday == 7 )
      wday = 0;
    // Wenn letzter Tag im Monat, Monat aufaddieren
    if ( day == DayOfMonth[month - 1] ) { // next month
      day = 0;
      month++;
    }
    day++;
  }

  // Datenstruktur updaten 
  t->month = month;
  t->hour = hour;
  t->day = day;
  t->wday = wday;
}

//=============================================================================
// Setup()
//=============================================================================

void setup() {

  // Set Port F und K to output
  DDRK = 0xff;
  DDRF = 0xff;

  pinMode(buttonPin, INPUT_PULLUP);

  // delay(1000);
  Wire.begin();

  Serial.begin(115200);
  Serial.println("VFD Display starting...");

  Wire.beginTransmission(0x68); // address DS3231
  Wire.write(0x0E); // select register
  Wire.write(0b00011100); // write register bitmap, bit 7 is /EOSC
  Wire.endTransmission();

  Serial.print("GPS starting...");
  GPS.begin(9600);
  Serial.println("OK"); // No check right now

  Serial.print("BMP180 starting...");
  if (bmp.begin()) {
    Serial.println("OK");
  }
  else {
    Serial.println("NOK");
  }

  Serial.print("SI1132 Luminicenz Sensor starting...");
  if (uv.begin()) {
    Serial.println("OK");
  }
  else {
    Serial.println("NOK");
  }  

  Serial.print("Temp/Humi Sensor starting...");
  if (sensor.begin()) {
    Serial.println("OK");
  }
  else {
    Serial.println("NOK");
  }  

  VFD_Init();
  VFD_DisplaySetup(LAYER0_ON, LAYER1_OFF, DISPLAY_ON, REVERSE_OFF, MODE_OR);
  VFD_AddressIncrementMode(HORIZONTAL_OFF, VERTICAL_ON);
  VFD_SetBrightness(5); // 0 -

  select_font(FONT5X7);
  put_txt("GPS Display V 0.9", 0, 0);
  put_txt("by D.Buergin", 0, 1);
  put_txt("14-Sep-2018", 0, 2);

  // uncomment this line to turn on RMC (recommended minimum) and GGA (fix data) including altitude
  GPS.sendCommand(PMTK_SET_NMEA_OUTPUT_RMCGGA);
  // uncomment this line to turn on only the "minimum recommended" data
  //GPS.sendCommand(PMTK_SET_NMEA_OUTPUT_RMCONLY);
  // For parsing data, we don't suggest using anything but either RMC only or RMC+GGA since
  // the parser doesn't care about other sentences at this time
  // Set the update rate
  GPS.sendCommand(PMTK_SET_NMEA_UPDATE_1HZ); // 1 Hz update rate
  // For the parsing code to work nicely and have time to sort thru the data, and
  // print it out we don't suggest using anything higher than 1 Hz

  // Request updates on antenna status, comment out to keep quiet
  GPS.sendCommand(PGCMD_ANTENNA);

  delay(2000);
  VFD_ClearDisplay();

}

//=============================================================================
// Main Loop()
//
// disp_zeile1          : dd.mm.yyyy hh:mn:ss
// disp_Zeile_big_km    : 120km hh:mn wenn GPRMC = valid sonst 000km hh:mn
// disp_zeile_big       : hh:mn:ss
// disp_zeile2_speed    : %03u.%02u Km/h
// disp_zeile1_latitude : "%c:%03u%c%02u.%04u %03u.%02u
// disp_zeile2_longitude: "%c:%03u%c%02u.%04u
//
// 0: disp_Zeile_big_km
// 1: disp_zeile_big
// 2: disp_zeile1
//    disp_zeile2_speed
//    disp_zeile2_hoehe
// 3: disp_zeile1_latitude
//    disp_zeile2_longitude
//    disp_zeile2_sats
// 4: disp_zeile1_dbg
//    disp_zeile2_dbg
//
// $PGTOP,11,2*6E
// $GPGGA,195618.000,4641.0743,N,00741.2181,E,1,03,7.30,102.0,M,48.0,M,,*69
// $GPRMC,195618.000,A,4641.0743,N,00741.2181,E,0.31,158.96,200918,,,A*60
//
// $PGTOP,11,2*6E
// $GPGGA,195618.214,4641.0741,N,00741.2185,E,1,03,7.29,102.0,M,48.0,M,,*60
// $GPRMC,195618.214,A,4641.0741,N,00741.2185,E,0.33,144.03,200918,,,A*62

// Time: 20:5:10.0
// Date: 20/9/2018
// Fix: 1 quality: 1
// Location: 4641.2128N, 741.1931E
// Speed (knots): 0.29
// Angle: 76.13
// Altitude: 407.10
// Satellites: 4
//
// Km/h = knots * 1.852
//=============================================================================

void loop() {
  char buf[21];

  //=====================================================================================
  // Globale Variablen fuer den Display
  //=====================================================================================

  // Fuer den 5x7Font brauchen wir 2 Zeilen a 20 Zeichen

  char disp_zeile1[32];
  char disp_zeile2_speed[32];

  // Laengen und Breiten grad
  char disp_zeile_latitude[32];
  char disp_zeile_longitude[32];
  char disp_zeile_sensor[32];
  char disp_zeile_sensor2[32];
  char disp_zeile_helligkeit[32];

  // Die Anzahl Sateliten ist im GGA Satz, und wir separat eingefuegt
  char disp_zeile_sats[32];

  // Zeitanzeige gross
  // Fuer den 10x14Font brauchen wir 12 Zeichen
  // 12:12:12
  char disp_zeile_big[32];

  // Zeitanzeige gross mit Km/h
  // Fuer den 10x14Font brauchen wir 12 Zeichen
  char disp_zeile_big_km[32];

  // Alt: 1111m Head: 180
  char disp_alt_head[32];

  // Welcher Display wird gerade angezeigt
  // 0 = Zeit/Datum/Geschwindigkeit/Hoehe/Anzahl Satelliten
  // 1 = Zeit/Datum/Innen_Temp/Aussen_Temp
  // 2 = Zeit im doppelt hohen Format
  // 3 = Km/h und Zeit im doppelt hohen Format
  // 4 = Koordinaten
  // 5 = GPS/Temp Debug

  float kmh;
  int kmh_g = 0;
  int kmh_n = 0;
  int kmh_r = 0;

  int hoehe = 0;

  int long_g = 0;
  int long_m = 0;
  int long_s = 0;

  int lat_g = 0;
  int lat_m = 0;
  int lat_s = 0;

  // --------------------------------------------------------------------------------------------
  // Here we start....
  // --------------------------------------------------------------------------------------------

  // Button einlesen und debouncen..
  reading = digitalRead(buttonPin);

  if (reading != lastButtonState) {
    lastDebounceTime = millis();
  }

  if ((millis() - lastDebounceTime) > debounceDelay) {
    if (reading != buttonState) {
      buttonState = reading;

      if (buttonState == LOW) {
        Serial.print("Button Press: ");
        Serial.println(disp_state, DEC);
        
        disp_state++;
        if (disp_state > 4) disp_state = 0;
      }
    }
  }
  lastButtonState = reading;

  // Characters vom GPS einlesen und versuchen einen ganze Satz zu bilden (passiert in der GPS
  // Instanz
  char c = GPS.read();

  // if you want to debug, this is a good time to do it!
  // if (GPSECHO)
  // if (c) Serial.print(c);

  // if a sentence is received, we can check the checksum, parse it...
  if (GPS.newNMEAreceived()) {
    // a tricky thing here is if we print the NMEA sentence, or data
    // we end up not listening and catching other sentences!
    // so be very wary if using OUTPUT_ALLDATA and trytng to print out data
    // Serial.println(GPS.lastNMEA()); // this also sets the newNMEAreceived() flag to false
    if (!GPS.parse(GPS.lastNMEA())) // this also sets the newNMEAreceived() flag to false
      return; // we can fail to parse a sentence in which case we should just wait for another
  }

  // if millis() or timer wraps around, we'll just reset it
  if (timer > millis()) timer = millis();

  // approximately every 2 seconds or so, print out the current stats
  if (millis() - timer > 1000) {
    timer = millis(); // reset the timer
    sec_counter++;

    // Serial.println("Sekunden Loop");
    // bmp.readTemperature());
    // bmp.readPressure());
    // uv.readVisible() // uint16_t return visible+IR light levels
    // uv.readIR()
    // uv.readUV() // Is Integer (*100) so devide by 100 to get real result
    // float hum = sensor.readHumidity()
    // float temp = sensor.readTemperature()
    Helligkeit = uv.readVisible();
    Serial.print("Vis: ");Serial.println(Helligkeit,DEC);
    
    // Luftdruck auslesen und ungefaehr auf 558müH korrigieren 
    // (1hPA pro 8m = 559 / 8 = 69.8)
    // p0 = 1011.2
    // Zurueck kommen MiliPascal, also z.B. 95600 
    Pressure = bmp.readPressure() + 6000;
    
    Temp = sensor.readTemperature();
    Humi = sensor.readHumidity();

    // 0123456789023456789
    // T: 12.3 H: 44.5% P: 1015 
    sprintf(disp_zeile_sensor, "Baro: %d", (int)(Pressure / 100));
    sprintf(disp_zeile_sensor2, "Temp: %d.%1d Hum: %d.%1d", (int)(Temp), (int)((Temp - (int)(Temp) ) * 10), (int)(Humi), (int)((Humi - (int)(Humi)) *10));
     
    // Helligkeit der VFD Anzeige anpassen
    // Je heller die Umgebung, je heller das VFD Display
    // Mind 1 max 15 (Achtung mA...) 

    if ((Helligkeit > 0 ) && (Helligkeit < 270)) bright = 1;
    if ((Helligkeit > 269 ) && (Helligkeit < 280)) bright = 5;
    if ((Helligkeit > 279 ) && (Helligkeit < 300)) bright = 10;
    if (Helligkeit > 299) bright = 15;

    VFD_SetBrightness(bright);
    
    sprintf(disp_zeile_helligkeit, "UV: %d B: %d", Helligkeit, bright );
    
    sprintf(disp_zeile1, "%02d.%02d.%04d   %02d:%02d:%02d",
            Clock.getDate(),
            Clock.getMonth(Century),
            (Clock.getYear() + 2000),
            Clock.getHour(h12, PM),
            Clock.getMinute(),
            Clock.getSecond());

    sprintf(disp_zeile_big, "%02d:%02d:%02d",
            Clock.getHour(h12, PM),
            Clock.getMinute(),
            Clock.getSecond());

    sprintf(disp_zeile_big_km, "000 %02d:%02d",
            Clock.getHour(h12, PM),
            Clock.getMinute(),
            Clock.getSecond());

    sprintf(disp_alt_head, "Head: 000 Alt: 000");
    sprintf(disp_zeile_sats, "Sats: 0 Fix: 0 Q: 0");

    sprintf(disp_zeile_latitude, "no latitude");
    sprintf(disp_zeile_longitude, "no longitude");
    sprintf(disp_zeile2_speed, "000.00 Kmh");
    /*
      Serial.print("\nTime: ");
      Serial.print(GPS.hour, DEC); Serial.print(':');
      Serial.print(GPS.minute, DEC); Serial.print(':');
      Serial.print(GPS.seconds, DEC); Serial.print('.');
      Serial.println(GPS.milliseconds);
      Serial.print("Date: ");
      Serial.print(GPS.day, DEC); Serial.print('/');
      Serial.print(GPS.month, DEC); Serial.print("/20");
      Serial.println(GPS.year, DEC);
      Serial.print("Fix: "); Serial.print((int)GPS.fix);
      Serial.print(" quality: "); Serial.println((int)GPS.fixquality);
    */
    if (GPS.fix) {
      /*
        Serial.print("Location: ");
        Serial.print(GPS.latitude, 4); Serial.print(GPS.lat);
        Serial.print(", ");
        Serial.print(GPS.longitude, 4); Serial.println(GPS.lon);
        Serial.print("Speed (knots): "); Serial.println(GPS.speed);
        Serial.print("Angle: "); Serial.println(GPS.angle);
        Serial.print("Altitude: "); Serial.println(GPS.altitude);
        Serial.print("Satellites: "); Serial.println((int)GPS.satellites);
      */

      // Set RTC Time the first time we have a fix and then every 5min
      if ((set_time) || (sec_counter > 300)) {
        // Zeit auf UTC+1 korrigieren
        tm.second = GPS.seconds;
        tm.minute = GPS.minute;
        tm.hour = GPS.hour;
        tm.day = GPS.day;
        tm.month = GPS.month;
        tm.year = GPS.year + 2000;

        ts = mktime(&tm);
        ts += 3600; // UTC+1 Korrektur

        // Wieder zurueck verwandeln
        gettime(ts, &tm);

        // Checken ob gerade Sommerzeit ist, wenn ja, Zeit anpassen
        sommerzeit(&tm);

        Serial.println("Setting RTC Time from GPS");
        Clock.setSecond(tm.second);
        Clock.setMinute(tm.minute);
        Clock.setHour(tm.hour);
        Clock.setDate(tm.day);
        Clock.setMonth(tm.month);
        Clock.setYear(tm.year - 2000);
        set_time = false;
        sec_counter = 0;
      }

      kmh = GPS.speed * 1.852;
      kmh_r = round(kmh);
      kmh_g = (int)kmh;
      kmh_n = (kmh - (float)kmh_g) * 100;

      sprintf(disp_zeile_big_km, "%03u %02d:%02d",
              kmh_r,
              Clock.getHour(h12, PM),
              Clock.getMinute(),
              Clock.getSecond());

      sprintf(disp_zeile2_speed, "%03u.%02u Kmh",
              kmh_g,
              kmh_n);

      if (GPS.satellites > 3)
      {
        // Head: 123 Alt: 1234
        sprintf(disp_alt_head, "Head: %03u Alt: %04um", (int)GPS.angle, (int)GPS.altitude + (int)GPS.geoidheight );
      }
      else
      {
        sprintf(disp_alt_head, "Head: 000 Alt: 000m");
      }

      sprintf(disp_zeile_sats, "Sats: %u Fix: %u Q: %u", (int)GPS.satellites, (int)GPS.fix, (int)GPS.fixquality);

      // Location: 4641.3173N, 741.1346E
      lat_g = (int)(GPS.latitude / 100); // 46
      lat_m = (int)GPS.latitude - (lat_g * 100); // 41
      lat_s = ((GPS.latitude - (int)GPS.latitude) * 10000);

      long_g = (int)(GPS.longitude / 100); // 46
      long_m = (int)GPS.longitude - (long_g * 100); // 41
      long_s = ((GPS.longitude - (int)GPS.longitude) * 10000);

      sprintf(disp_zeile_latitude, "%c %03u.%02u.%04u", GPS.lat, lat_g, lat_m, lat_s);
      sprintf(disp_zeile_longitude, "%c %03u.%02u.%04u", GPS.lon, long_g, long_m, long_s);

    }

    // 125 13:45
    if (disp_state == 0) {
      VFD_ClearDisplay();
      select_font(FONT10X14);
      // gut = 18,48
      put_txt(disp_zeile_big_km, 8, 1);
    }
    // 125 km/h
    else if (disp_state == 1) {
      VFD_ClearDisplay();
      select_font(FONT10X14);
      put_txt(disp_zeile2_speed, 5, 1);
    }
    // 13:42:01
    else if (disp_state == 2) {
      VFD_ClearDisplay();
      select_font(FONT10X14);
      // gut = 18,48
      put_txt(disp_zeile_big, 18, 1);
    }
    else if (disp_state == 3) {
      VFD_ClearDisplay();
      select_font(FONT5X7);
      // gut = 18,48
      put_txt(disp_alt_head, 0, 0);
      put_txt(disp_zeile_sats, 0, 1);
      put_txt(disp_zeile_latitude, 0, 2);
      put_txt(disp_zeile_longitude, 0, 3);      
    }
    else if (disp_state == 4) {
      VFD_ClearDisplay();
      select_font(FONT5X7);
      // gut = 18,48
      put_txt(disp_zeile1, 0, 0);
      put_txt(disp_zeile_sensor, 0, 1);
      put_txt(disp_zeile_sensor2, 0, 2);
      put_txt(disp_zeile_helligkeit, 0, 3);
    }
  }
}
